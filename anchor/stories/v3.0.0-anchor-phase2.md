# Story: v3.0.0 sol-anchor-zig Phase 2 - PDA Support

> 实现 PDA (Program Derived Address) 支持，包括 seeds 约束、bump 存储和账户初始化。

## 目标

实现 sol-anchor-zig Phase 2 PDA 支持，提供 Anchor 兼容的 PDA 开发模式：

1. **Seeds 类型系统** - 编译期种子规范和运行时解析
2. **PDA 验证** - 验证账户地址匹配预期 PDA
3. **Bump 存储** - Context.bumps 存储和检索
4. **账户初始化** - 通过 CPI 在 PDA 地址创建账户

## 验收标准

### anchor/src/seeds.zig

- [x] `SeedSpec` 联合类型
  - [x] `literal` - 字面量字节 (字符串常量)
  - [x] `field` - 账户数据字段引用
  - [x] `account` - 其他账户公钥引用
  - [x] `bump` - bump 种子引用
- [x] `seed(literal)` - 创建字面量种子
- [x] `seedField(name)` - 创建字段引用种子
- [x] `seedAccount(name)` - 创建账户引用种子
- [x] `seedBump(name)` - 创建 bump 引用种子
- [x] `MAX_SEEDS` 常量 (16)
- [x] `MAX_SEED_LEN` 常量 (32)
- [x] `SeedBuffer` - 运行时种子解析缓冲区
- [x] `resolveComptimeSeeds()` - 编译期种子解析
- [x] `areAllLiteralSeeds()` - 检查种子类型
- [x] `validateSeeds()` - 种子验证
- [x] `fieldNameHash()` - 字段名哈希
- [x] 单元测试

### anchor/src/pda.zig

- [x] `validatePda(account_key, seeds, program_id)` - 验证 PDA
- [x] `validatePdaWithBump(account_key, seeds, bump, program_id)` - 使用已知 bump 验证
- [x] `derivePda(seeds, program_id)` - 派生 PDA 地址和 bump
- [x] `createPdaAddress(seeds, bump, program_id)` - 使用已知 bump 创建 PDA
- [x] `isPda(address)` - 检查地址是否是 PDA
- [x] `PdaError` 错误类型
  - [x] InvalidPda
  - [x] SeedsTooLong
  - [x] BumpMismatch
  - [x] InvalidSeeds
  - [x] DerivationFailed
  - [x] MaxSeedLengthExceeded
- [x] 单元测试

### anchor/src/init.zig

- [x] `InitConfig` 配置结构体
  - [x] `space: usize` - 账户大小
  - [x] `payer: []const u8` - 付款账户字段名
  - [x] `owner: PublicKey` - 新账户所有者
- [x] `createAccount(payer, new_account, owner, space, system_program)` - 创建普通账户
- [x] `createAccountAtPda(payer, new_account, owner, space, seeds, bump, program_id, system_program)` - 在 PDA 创建账户
- [x] `rentExemptBalance(space)` - 计算免租金余额
- [x] `rentExemptBalanceDefault(space)` - 使用默认值计算
- [x] `isUninitialized(info)` - 检查账户是否未初始化
- [x] `validateForInit(info)` - 验证账户可初始化
- [x] `InitError` 错误类型
- [x] 单元测试

### anchor/src/account.zig 扩展

- [x] `AccountConfig` 新增字段
  - [x] `seeds: ?[]const SeedSpec` - PDA 种子规范
  - [x] `bump: bool` - 是否存储 bump
  - [x] `init: bool` - 是否初始化新账户
  - [x] `payer: ?[]const u8` - 付款账户 (init 需要)
- [x] `HAS_SEEDS` 常量 - 是否有种子约束
- [x] `HAS_BUMP` 常量 - 是否存储 bump
- [x] `IS_INIT` 常量 - 是否需要初始化
- [x] `SEEDS` 常量 - 种子规范
- [x] `PAYER` 常量 - 付款账户字段名
- [x] 编译期配置验证
- [x] `AccountError` 扩展 (ConstraintSeeds, InvalidPda)
- [x] PDA 验证方法
  - [x] `LoadPdaResult` - 返回账户和 bump 的结构体
  - [x] `loadWithPda(info, seeds, program_id)` - 加载并验证 PDA，返回 bump
  - [x] `loadWithPdaBump(info, seeds, bump, program_id)` - 使用已知 bump 验证
  - [x] `requiresPdaValidation()` - 检查是否需要 PDA 验证
  - [x] `requiresInit()` - 检查是否需要初始化
- [x] 单元测试

### anchor/src/context.zig 扩展

- [x] `Bumps` 增强
  - [x] `MAX_BUMPS` 常量 (16)
  - [x] `BumpEntry` 结构体
  - [x] `get(comptime name)` - 编译期字段名获取
  - [x] `set(comptime name, bump)` - 设置 bump
  - [x] `getByKey(key)` - 运行时键获取
  - [x] `setByKey(key, bump)` - 运行时键设置
  - [x] `count()` - 获取存储数量
  - [x] `contains(name)` - 检查是否包含
  - [x] `hashNameRuntime(name)` - 运行时哈希
- [x] PDA 集成到账户加载
  - [x] `loadAccountsWithPda(Accounts, program_id, infos)` - 加载账户并验证 PDA
  - [x] `parseContext(Accounts, program_id, infos)` - 自动 PDA 验证 (literal-only seeds)
  - [x] `parseContextBasic(Accounts, program_id, infos)` - 手动 PDA 控制
  - [x] `LoadAccountsResult` - 返回账户和 bumps 的辅助类型
- [x] 单元测试

### anchor/src/root.zig

- [x] 导出 seeds 模块
- [x] 导出 pda 模块
- [x] 导出 init 模块
- [x] 更新文档和示例
- [x] Phase 2 子模块测试

### 集成

- [x] 所有测试通过 (464 tests)
- [x] 与 Phase 1 向后兼容

## Rust 源码引用

| 模块 | Rust 源码 |
|------|----------|
| seeds.zig | https://github.com/coral-xyz/anchor/blob/master/lang/syn/src/codegen/accounts/seeds.rs |
| pda.zig | https://github.com/coral-xyz/anchor/blob/master/lang/src/accounts/account.rs |
| init.zig | https://github.com/coral-xyz/anchor/blob/master/lang/syn/src/codegen/accounts/init.rs |

## 架构设计

### Seed 类型系统

```
Anchor 格式:
#[account(
    seeds = [b"counter", authority.key().as_ref()],
    bump,
)]

Zig 等价:
const Counter = anchor.Account(CounterData, .{
    .discriminator = anchor.accountDiscriminator("Counter"),
    .seeds = &.{
        anchor.seed("counter"),
        anchor.seedAccount("authority"),
    },
    .bump = true,
});
```

### SeedSpec 定义

```zig
pub const SeedSpec = union(enum) {
    /// 字面量字节种子
    literal: []const u8,
    /// 账户数据字段引用 (用于嵌入在账户中的公钥等)
    field: []const u8,
    /// 其他账户的公钥引用
    account: []const u8,
    /// bump 种子引用
    bump: []const u8,
};
```

### PDA 验证流程

```
自动验证流程 (literal-only seeds):
1. parseContext() 调用 loadAccountsWithPda()
2. 对每个 HAS_SEEDS 账户检查 SEEDS 是否全部为 literal
3. areAllLiteralSeeds() 返回 true 时，resolveComptimeSeeds() 解析种子
4. 调用 loadWithPda(info, resolved_seeds, program_id)
5. validatePda() 验证地址并返回 bump
6. bump 存入 result.bumps

手动验证流程 (seedAccount/seedField seeds):
1. parseContextBasic() 加载账户但跳过 PDA 验证
2. 用户在加载其他账户后手动调用 Account.loadWithPda()
3. 传入已解析的种子值 (包含账户公钥等)
4. bump 需要手动存储到 context.bumps
```

### loadWithPda API

```zig
// 自动发现 bump
const result = try Counter.loadWithPda(&info, .{"counter"}, &program_id);
const counter = result.account;
const bump = result.bump;

// 使用已知 bump (更高效)
const counter = try Counter.loadWithPdaBump(&info, .{"counter"}, 254, &program_id);
```

### 账户初始化流程

```
1. 检查 AccountConfig.init = true
2. 解析种子并派生 PDA
3. 计算 rent-exempt 余额
4. 调用 system_program.createAccount via CPI
5. 写入 discriminator
6. 存储 bump (如果配置)
```

## 使用示例

### 基本 PDA 账户

```zig
const anchor = @import("sol_anchor_zig");
const sol = anchor.sdk;

// 定义 PDA 账户数据
const CounterData = struct {
    count: u64,
    authority: sol.PublicKey,
    bump: u8,
};

// 创建带 PDA 约束的账户类型
const Counter = anchor.Account(CounterData, .{
    .discriminator = anchor.accountDiscriminator("Counter"),
    .seeds = &.{
        anchor.seed("counter"),
        anchor.seedAccount("authority"),
    },
    .bump = true,
});

// 定义初始化指令账户
const InitializeAccounts = struct {
    counter: Counter,
    authority: anchor.Signer,
    payer: anchor.SignerMut,
    system_program: anchor.Program(sol.system_program.ID),
};

// 指令处理函数
fn initialize(ctx: anchor.Context(InitializeAccounts)) !void {
    const counter = ctx.accounts.counter;

    // 访问类型化数据
    counter.data.count = 0;
    counter.data.authority = ctx.accounts.authority.key().*;

    // 从 context.bumps 获取 bump
    counter.data.bump = ctx.bumps.get("counter").?;
}
```

### 使用字段种子

```zig
// 用户特定的数据账户
const UserDataAccount = struct {
    user: sol.PublicKey,
    data: [64]u8,
    bump: u8,
};

const UserData = anchor.Account(UserDataAccount, .{
    .discriminator = anchor.accountDiscriminator("UserData"),
    .seeds = &.{
        anchor.seed("user_data"),
        anchor.seedField("user"),  // 引用账户数据中的 user 字段
    },
    .bump = true,
});
```

## 测试用例

### seeds.zig 测试

1. **种子解析**
   - 解析字符串字面量种子
   - 解析字段引用种子
   - 解析账户引用种子
   - 解析混合种子数组

2. **编译期解析**
   - resolveComptimeSeeds 正确解析字面量
   - areAllLiteralSeeds 正确识别类型
   - validateSeeds 验证种子规范

### pda.zig 测试

1. **PDA 验证**
   - 有效 PDA 匹配种子 → 成功
   - 错误 PDA 地址 → InvalidPda 错误

2. **PDA 派生**
   - derivePda 返回正确地址和 bump
   - 地址是有效 PDA (off curve)

### context.zig 测试

1. **Bumps 存储**
   - get/set 正常工作
   - getByKey/setByKey 正常工作
   - count 返回正确数量
   - contains 正确检查
   - hashNameRuntime 与编译期哈希一致

2. **PDA 集成加载**
   - loadAccountsWithPda 返回 accounts 和 bumps
   - parseContextBasic 不进行 PDA 验证
   - LoadAccountsResult 类型正确定义

### account.zig 测试

1. **PDA 方法**
   - LoadPdaResult 结构体可访问
   - loadWithPda 对非 PDA 地址返回 ConstraintSeeds
   - loadWithPdaBump 对错误 bump 返回 ConstraintSeeds
   - requiresPdaValidation 正确检查
   - requiresInit 正确检查

### init.zig 测试

1. **租金计算**
   - rentExemptBalanceDefault 正确计算
   - 使用正确的默认参数

2. **初始化检查**
   - isUninitialized 正确识别
   - validateForInit 验证账户状态

## 依赖

已实现的模块:
- `src/public_key.zig` - `findProgramAddress()`, `createProgramAddress()`
- `src/system_program.zig` - `createAccount()` 指令
- `src/instruction.zig` - CPI `invoke()`, `invokeSigned()`
- `src/rent.zig` - Rent 计算
- Phase 1 所有模块

## 后续阶段

### Phase 3: 高级约束
- `has_one` 关联验证
- `constraint` 自定义表达式
- `close` 账户关闭
- `realloc` 重新分配

### Phase 4: 序列化
- Borsh 序列化支持
- 自动派生序列化
- 零拷贝账户访问

## 完成状态

- 开始日期: 2026-01-08
- 完成日期: 2026-01-08
- 状态: ✅ 已完成

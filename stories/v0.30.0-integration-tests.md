# Story: v0.30.0 Rust-Zig 集成测试

> 使用官方 Rust SDK 生成测试向量，验证 Zig SDK 实现的兼容性和正确性

## 背景

当前 Zig SDK 的单元测试都是独立编写的，缺少与官方 Rust SDK 的交叉验证。为确保 Zig 实现与 Rust 实现完全兼容，需要：

1. 使用 Rust SDK 生成序列化的测试向量
2. Zig SDK 反序列化并验证结果
3. 确保两端的数据格式完全一致

## 测试架构

```
┌─────────────────────────────────────────────────────────────┐
│                    Rust Test Vector Generator                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  使用官方 solana-sdk crates 生成:                     │   │
│  │  - bincode 序列化数据                                 │   │
│  │  - borsh 序列化数据                                   │   │
│  │  - JSON 格式数据                                      │   │
│  │  - Base58 编码字符串                                  │   │
│  └─────────────────────────────────────────────────────┘   │
│                           │                                  │
│                           ▼                                  │
│              test-vectors/ (生成的测试数据)                   │
│              ├── bincode/                                    │
│              │   ├── instruction_error.bin                   │
│              │   ├── transaction_error.bin                   │
│              │   └── loader_instruction.bin                  │
│              ├── json/                                       │
│              │   ├── epoch_info.json                         │
│              │   └── pubkey.json                             │
│              └── base58/                                     │
│                  ├── pubkeys.txt                             │
│                  └── signatures.txt                          │
└─────────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│                    Zig Integration Tests                     │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  读取 Rust 生成的测试向量:                            │   │
│  │  - 反序列化 bincode 数据                              │   │
│  │  - 解析 JSON 数据                                     │   │
│  │  - 验证 Base58 编解码                                 │   │
│  │  - 比对结果与预期值                                   │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

## 测试范围

### Phase 1: 核心类型兼容性 (P0)

| 测试项 | Rust Crate | Zig Module | 验证内容 |
|--------|------------|------------|----------|
| PublicKey | `solana-pubkey` | `public_key.zig` | Base58 编解码、字节序列 |
| Hash | `solana-hash` | `hash.zig` | 十六进制编解码、SHA256 |
| Signature | `solana-signature` | `signature.zig` | Base58 编解码、验证 |
| Keypair | `solana-keypair` | `keypair.zig` | 签名生成、验证 |

### Phase 2: 序列化兼容性 (P0)

| 测试项 | 序列化格式 | 验证内容 |
|--------|-----------|----------|
| InstructionError | bincode | 所有 ~50 种错误变体 |
| TransactionError | bincode | 所有 ~35 种错误变体 |
| UpgradeableLoaderInstruction | bincode | 所有 10 种指令类型 |
| AccountMeta | bincode | 账户元数据序列化 |
| CompiledInstruction | bincode | 编译后指令格式 |

### Phase 3: JSON 兼容性 (P1)

| 测试项 | 验证内容 |
|--------|----------|
| EpochInfo | camelCase 字段名、可选字段处理 |
| RPC 响应格式 | 为 Client SDK 做准备 |

### Phase 4: PDA 派生兼容性 (P0)

| 测试项 | 验证内容 |
|--------|----------|
| findProgramAddress | 多种 seeds 组合 |
| createProgramAddress | 边界条件测试 |
| getProgramDataAddress | BPF Loader 地址派生 |

## 实现计划

### Step 1: 目录结构

```
program-test/
├── Cargo.toml                    # 添加新依赖
├── src/
│   └── lib.rs                    # Rust 测试向量生成库
├── tests/
│   ├── pubkey.rs                 # 现有测试
│   └── generate_vectors.rs       # 测试向量生成
├── test-vectors/                 # 生成的测试数据 (gitignore)
│   ├── bincode/
│   ├── json/
│   └── base58/
├── integration/                  # Zig 集成测试
│   ├── build.zig
│   ├── test_bincode.zig
│   ├── test_json.zig
│   └── test_pubkey.zig
└── test.sh                       # 更新测试脚本
```

### Step 2: Rust 依赖更新

```toml
# Cargo.toml 新增依赖
[dependencies]
solana-instruction-error = "3.0"
solana-transaction-error = "3.0"
solana-loader-v3-interface = "3.0"
solana-epoch-info = "3.0"
solana-hash = "3.0"
solana-signature = "3.0"
solana-keypair = "3.0"
bincode = "1.3"
serde_json = "1.0"
```

### Step 3: Rust 测试向量生成器

```rust
// src/lib.rs
use std::fs;
use std::path::Path;

pub fn generate_instruction_error_vectors(output_dir: &Path) {
    use solana_instruction_error::InstructionError;
    
    let errors = vec![
        InstructionError::GenericError,
        InstructionError::InvalidArgument,
        InstructionError::InvalidInstructionData,
        InstructionError::Custom(42),
        // ... 所有变体
    ];
    
    for (i, err) in errors.iter().enumerate() {
        let bytes = bincode::serialize(err).unwrap();
        let filename = output_dir.join(format!("instruction_error_{}.bin", i));
        fs::write(filename, bytes).unwrap();
    }
}

pub fn generate_pubkey_vectors(output_dir: &Path) {
    use solana_pubkey::Pubkey;
    
    let pubkeys = vec![
        Pubkey::default(),
        Pubkey::new_unique(),
        // 系统程序、BPF Loader 等已知 ID
    ];
    
    // 生成 Base58 和字节格式
}
```

### Step 4: Zig 集成测试

```zig
// integration/test_bincode.zig
const std = @import("std");
const sdk = @import("solana_sdk");

test "instruction_error: bincode compatibility with Rust" {
    const allocator = std.testing.allocator;
    
    // 读取 Rust 生成的测试向量
    const test_cases = [_]struct {
        file: []const u8,
        expected: sdk.InstructionError,
    }{
        .{ .file = "test-vectors/bincode/instruction_error_0.bin", .expected = .GenericError },
        .{ .file = "test-vectors/bincode/instruction_error_1.bin", .expected = .InvalidArgument },
        // ...
    };
    
    for (test_cases) |tc| {
        const data = try std.fs.cwd().readFileAlloc(allocator, tc.file, 1024);
        defer allocator.free(data);
        
        const parsed = try sdk.bincode.deserialize(sdk.InstructionError, data);
        try std.testing.expectEqual(tc.expected, parsed);
    }
}
```

### Step 5: 测试脚本更新

```bash
#!/usr/bin/env bash
# test.sh

set -e

# 1. 生成 Rust 测试向量
cargo run --manifest-path Cargo.toml --bin generate-vectors

# 2. 运行 Rust 单元测试
cargo test

# 3. 构建 Zig 程序
$ZIG build --summary all

# 4. 运行 Zig 集成测试
$ZIG build test-integration --summary all
```

## 验收标准

### 必须通过

- [x] PublicKey Base58 编解码与 Rust 完全一致
- [x] Hash Base58 编解码与 Rust 完全一致
- [x] Signature Base58 编解码与 Rust 完全一致
- [x] PDA 派生结果与 Rust 完全一致
- [x] Keypair 签名与 Rust 完全一致
- [x] EpochInfo 字段值与 Rust 完全一致
- [x] ShortVec 编解码与 Rust 完全一致
- [x] SHA256 哈希计算与 Rust 完全一致
- [x] Lamports 字符串解析与 Rust 完全一致
- [x] Rent 最小余额计算与 Rust 完全一致
- [x] Clock sysvar 字段值与 Rust 完全一致
- [x] EpochSchedule 计算与 Rust 完全一致
- [x] DurableNonce 派生与 Rust 完全一致
- [x] Bincode 整数序列化与 Rust 完全一致
- [x] Borsh 整数序列化与 Rust 完全一致
- [x] System 指令编码与 Rust 完全一致

### 未实现 (低优先级)

- [ ] InstructionError bincode 序列化 (需要 enum 编号完全一致)
- [ ] TransactionError bincode 序列化 (需要 enum 编号完全一致)
- [ ] UpgradeableLoaderInstruction bincode 序列化

### 测试覆盖

- [x] PublicKey 测试向量 (5 个)
- [x] Hash 测试向量 (3 个)
- [x] Signature 测试向量 (2 个)
- [x] PDA 测试向量 (4 个)
- [x] Keypair 测试向量 (4 个)
- [x] EpochInfo 测试向量 (5 个)
- [x] ShortVec 测试向量 (9 个)
- [x] SHA256 测试向量 (7 个)
- [x] Lamports 测试向量 (15 个, 包含有效和无效输入)
- [x] Rent 测试向量 (7 个, 覆盖常见账户大小)
- [x] Clock 测试向量 (4 个, 包含边界值)
- [x] EpochSchedule 测试向量 (10 个, warmup 和 no-warmup)
- [x] DurableNonce 测试向量 (4 个, 哈希派生验证)
- [x] Bincode 测试向量 (11 个, 整数和布尔类型)
- [x] Borsh 测试向量 (11 个, 整数和布尔类型)
- [x] System 指令测试向量 (6 个, Transfer/CreateAccount/Assign/Allocate)
- [x] 边界条件和特殊值测试

## 预期收益

1. **兼容性保证**: 确保 Zig SDK 与 Rust SDK 完全兼容
2. **回归测试**: 防止后续修改破坏兼容性
3. **文档价值**: 测试向量本身是很好的格式文档
4. **Client SDK 基础**: 为 v1.1.0 Client SDK 打下基础

## 风险与挑战

1. **Rust SDK 版本更新**: 需要跟踪 Rust SDK 版本变化
2. **bincode 版本差异**: Rust bincode 有多个版本，需确认版本
3. **测试向量维护**: 需要在 Rust SDK 更新时重新生成

## 时间估计

| 阶段 | 估计时间 |
|------|----------|
| Phase 1: 核心类型 | 2-3 天 |
| Phase 2: 序列化 | 3-4 天 |
| Phase 3: JSON | 1-2 天 |
| Phase 4: PDA | 1-2 天 |
| **总计** | **7-11 天** |

## 完成状态

- 开始日期: 2026-01-06
- 完成日期: 2026-01-06
- 当前状态: ✅ 已完成

### 已完成工作

1. ✅ Rust 测试向量生成器 (`program-test/src/lib.rs`)
2. ✅ 测试向量生成二进制 (`program-test/src/bin/generate_vectors.rs`)
3. ✅ Zig 集成测试框架 (`program-test/integration/`)
4. ✅ PublicKey Base58 编解码测试 (5 vectors)
5. ✅ Hash Base58 编解码测试 (3 vectors)
6. ✅ 更新 test.sh 支持集成测试
7. ✅ Signature Base58 编解码测试 (2 vectors, SDK 已添加 toBase58 方法)
8. ✅ PDA 派生测试 (4 vectors, SDK 已添加 findProgramAddressSlice 运行时版本)
9. ✅ Keypair 签名兼容性测试 (4 vectors)
10. ✅ EpochInfo 字段值兼容性测试 (5 vectors)
11. ✅ 修复 CI: Rust imports 更新为 Solana SDK 3.0 格式
12. ✅ ShortVec 编解码测试 (9 vectors, 覆盖 1-3 字节编码)
13. ✅ SHA256 哈希计算测试 (7 vectors)
14. ✅ Lamports 字符串解析测试 (15 vectors, 有效/无效输入)
15. ✅ Rent 最小余额计算测试 (7 vectors, 常见账户大小)
16. ✅ Clock sysvar 字段值测试 (4 vectors, 包含边界值)
17. ✅ EpochSchedule 计算测试 (10 vectors, warmup 和 no-warmup)
18. ✅ DurableNonce 派生测试 (4 vectors, 哈希派生验证)
19. ✅ Bincode 序列化测试 (11 vectors, 整数/布尔/Option 类型)
20. ✅ Borsh 序列化测试 (11 vectors, 整数/布尔/Option 类型)
21. ✅ System 指令编码测试 (6 vectors, Transfer/CreateAccount/Assign/Allocate)

### 未实现工作 (低优先级)

1. ❌ InstructionError bincode 序列化 - 需要确保 Rust/Zig enum 编号完全一致，复杂度高
2. ❌ TransactionError bincode 序列化 - 同上

## 参考资料

- [solana-sdk GitHub](https://github.com/anza-xyz/solana-sdk)
- [bincode crate](https://docs.rs/bincode)
- [Solana RPC API](https://solana.com/docs/rpc)
